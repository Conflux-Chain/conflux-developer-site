---
id: conflux_storage
title: Storage
custom_edit_url: https://github.com/Conflux-Chain/conflux-developer-site/edit/master/docs/introduction/en/storage.md
keywords:
  - storage
---

Conflux introduced the Collateral for storage (CFS) mechanism as a pricing method for using storage. Compared with the one-time storage fee in Ethereum, the CFS mechanism will be more fair and reasonable. In principle, this mechanism requires a certain amount of funds to be locked as collateral to occupy storage space. Before the corresponding storage space is released or covered by others, the collateral will be locked, and the corresponding interest generated by the locked collateral will be directly allocated to the miners for the maintenance of the storage space. Therefore, the storage cost of Conflux also depends on the length of time the storage space is occupied. Conflux specifically introduced this mechanism in detail in its [Chapter 7 of Conflux_Protocol_Specification](https://confluxnetwork.org/files/Conflux_Protocol_Specification_20201020.pdf).

In the Conflux network, each storage entry occupies a space of 64B (B is Bytes, byte), which is also the size of the key/value pair in the world state. It should be noted that the key in the blockchain is generally 256bits long and the value It is also 256bits long (each is 32B long, and the total is 64B long). The deposit required for storage is proportional to the minimum multiple of 64B that can cover all stored items. For each storage entry, the last account that writes to the entry is called the owner of the storage entry. If a storage item is written during the execution of contract C, and a guarantor provides guarantee for it, then C is regarded as the writer of the item and accordingly becomes the owner of the item (see section 7.1 for details). In the world state, during the entire life cycle of a storage item, the owner of the item must lock a fixed amount of CFX as a storage deposit for the storage space. Specifically, for each storage entry with a size of 64B, its owner will be locked by 1/16CFX. For occupying `1KB` space, you will pay `1CFX` as a deposit, and the corresponding formula is as follows:

$$\left(\frac{1024}{64}\right)×\left(\frac{1}{16}\right)=1（CFX）$$

When account α becomes the owner of a stored entry (whether it is created or modified), α should immediately lock 1/16 CFX for the entry. If α has enough balance, then the required deposit will be automatically locked, otherwise if α does not have enough balance, the operation will fail and α cannot create or modify the entry.

When a storage item is deleted from the world state, the corresponding 1/16 CFX deposit will be unlocked and returned to the item owner's balance. If the ownership of a storage item changes, the 1/16 CFX deposit of the old owner is unlocked, and the new owner must lock 1/16 CFX as the deposit at the same time. It is worth mentioning that the deposit refund is "quietly" added to the balance, and there is no transfer transaction available for inquiry.

### Solidity memory management mechanism

According to the [Description](https://solidity-cn.readthedocs.io/zh/develop/introduction-to-smart-contracts.html#index-10) of the Solidity document on its memory management and Conflux [Storage Deposit Mechanism](https://mp.weixin.qq.com/s/KKU3XiJqr_Uz5RdlUyQmtA), we can find that the contract storage needs to be maintained with key and value. In general: the length of key is 256bits, and the length of value is also 256bits. The storage space of a smart contract is organized according to the following table, where {0,1}<sup>256</sup> represents a 256-bit string (there are only two values ​​of 0 or 1 in the bit string), **each key/value pair can be understood as an entry**:

Entry | Key/Address({0,1}<sup>256</sup>)   | value({0,1}<sup>256</sup>)  |
|  :----:  |  :----:  | :----:  |
1| 0...00000  | 0 |
2| 0...00001  | 1 |
3| 0...00002 | 2 |
...| ... | ... |
2<sup>256</sup>| f...fffff| 0 |

Since 256bits=32bytes, the corresponding length of two 256bits is: 32+32=64 (Bytes)

Summary of common variables and their corresponding entries in Solidity:

|   Variable   |                            Length                             |                      Definition Method                       |
| :------: | :---------------------------------------------------------: | :-------------------------------------------------: |
| Ordinary variables |                   1 ordinary variable corresponds to 1 entry                    |                uint public count=0;                 |
| mapping  |              Each key of mapping corresponds to 1 entry              |      mapping(address => uint) public balances;      |
|  array   | Each element of the array corresponds to 1 item, and the length of the array arr.length is an additional item | uint[5] fixedArr = [1,2,3,4,5]; string productname; |
|  struct  |              Accumulation of the number of entries corresponding to each field in the struct              |  struct Person {uint age;uint stuID;string name;}   |


## How to use storage mortgage

When users send a Conflux transaction, they need to fill in a `storageLimit` field (in bytes). The upper limit stipulates that the deposit increase of the deposit payer before and after the transaction is executed shall not exceed the `storage upper limit` multiplied by 1/1024 CFX. If this value is filled in too low, it will cause the deposit to exceed the upper limit after execution and the execution will fail. Therefore, in general, this field needs to be set to a value larger than the actual usage, and the excess part will not generate storage mortgage. However, it is not recommended to fill in too high, because it may cause the sender's balance to be insufficient to pay the deposit, which may result in transaction failure. Fullnode provides the RPC method `cfx_estimateGasAndCollateral` to estimate the storage size that a transaction will use.

After the transaction is executed, the `Receipt` contains several fields about storage changes:

* `storageCollateralized` This is the amount of data that is stored and mortgaged
* `storageCoveredBySponsor` Whether the storage mortgage for this transaction is sponsored by the sponsor
* `storageReleased` The storage released by this transaction

You can use the `cfx_getCollateralForStorage` method to query the storage size currently mortgaged by an address, the unit is bytes, and the value divided by 1024 is the amount of CFX storage mortgaged. In addition, it can also be obtained through the `cfx_getAccount` method, and the returned information contains the `collateralForStorage` field.
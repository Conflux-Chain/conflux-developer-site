(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{158:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return s})),r.d(t,"metadata",(function(){return i})),r.d(t,"toc",(function(){return c})),r.d(t,"default",(function(){return d}));var n=r(3),a=r(7),o=(r(0),r(185)),s={id:"storage",title:"Storage",custom_edit_url:"https://github.com/diem/diem/edit/main/storage/README.md"},i={unversionedId:"conflux-rust/core/src/pos/storage/storage",id:"conflux-rust/core/src/pos/storage/storage",isDocsHomePage:!1,title:"Storage",description:"The storage module provides reliable and efficient persistent storage for the",source:"@site/docs/conflux-rust/core/src/pos/storage/README.md",sourceDirName:"conflux-rust/core/src/pos/storage",slug:"/conflux-rust/core/src/pos/storage/storage",permalink:"/conflux-rust/core/src/pos/storage/storage",editUrl:"https://github.com/diem/diem/edit/main/storage/README.md",version:"current",frontMatter:{id:"storage",title:"Storage",custom_edit_url:"https://github.com/diem/diem/edit/main/storage/README.md"}},c=[{value:"Overview",id:"overview",children:[{value:"Ledger History",id:"ledger-history",children:[]},{value:"Ledger State",id:"ledger-state",children:[]},{value:"Events",id:"events",children:[]},{value:"Ledger Info and Signatures",id:"ledger-info-and-signatures",children:[]}]},{value:"Implementation Details",id:"implementation-details",children:[]},{value:"How is this module organized?",id:"how-is-this-module-organized",children:[]}],l={toc:c};function d(e){var t=e.components,s=Object(a.a)(e,["components"]);return Object(o.b)("wrapper",Object(n.a)({},l,s,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"The storage module provides reliable and efficient persistent storage for the\nentire set of data on the Diem Blockchain, as well as the necessary data used\ninternally by Diem Core."),Object(o.b)("h2",{id:"overview"},"Overview"),Object(o.b)("p",null,"The storage module is designed to serve two primary purposes:"),Object(o.b)("ol",null,Object(o.b)("li",{parentName:"ol"},"Persist the blockchain data, specifically the transactions and their outputs\nthat have been agreed by validators via consensus protocol."),Object(o.b)("li",{parentName:"ol"},"Provide a response with Merkle proofs to any query that asks for a part of the\nblockchain data. A client can easily verify the integrity of the response if\nthey have obtained the correct root hash.")),Object(o.b)("p",null,"The Diem Blockchain can be viewed as a Merkle tree consisting of the following\ncomponents:"),Object(o.b)("p",null,Object(o.b)("img",{alt:"data",src:r(281).default})),Object(o.b)("h3",{id:"ledger-history"},"Ledger History"),Object(o.b)("p",null,"Ledger history is represented by a Merkle accumulator. Each time a transaction\n",Object(o.b)("inlineCode",{parentName:"p"},"T")," is added to the blockchain, a ",Object(o.b)("em",{parentName:"p"},"TransactionInfo")," structure containing the\ntransaction ",Object(o.b)("inlineCode",{parentName:"p"},"T"),", the root hash for the state Merkle tree after the execution of\n",Object(o.b)("inlineCode",{parentName:"p"},"T")," and the root hash for the event Merkle tree generated by ",Object(o.b)("inlineCode",{parentName:"p"},"T")," is appended to\nthe accumulator."),Object(o.b)("h3",{id:"ledger-state"},"Ledger State"),Object(o.b)("p",null,"The ledger state at each version is represented by a sparse Merkle tree that has the\nstate of all accounts. The keys are the 256-bit hash of the addresses, and their\ncorresponding value is the state of the entire account serialized as a binary\nblob. While a tree of size ",Object(o.b)("inlineCode",{parentName:"p"},"2^256")," is an intractable representation, subtrees\nconsisting entirely of empty nodes are replaced with a placeholder value, and\nsubtrees consisting of exactly one leaf are replaced with a single node."),Object(o.b)("p",null,"While each ",Object(o.b)("em",{parentName:"p"},"TransactionInfo")," structure points to a different state tree, the new\ntree can reuse unchanged portion of the previous tree, forming a persistent data\nstructure."),Object(o.b)("h3",{id:"events"},"Events"),Object(o.b)("p",null,"Each transaction emits a list of events and those events form a Merkle accumulator.\nSimilar to the state Merkle tree, the root hash of the event accumulator of a\ntransaction is recorded in the corresponding ",Object(o.b)("em",{parentName:"p"},"TransactionInfo")," structure."),Object(o.b)("h3",{id:"ledger-info-and-signatures"},"Ledger Info and Signatures"),Object(o.b)("p",null,"A ",Object(o.b)("em",{parentName:"p"},"LedgerInfo")," structure that has the root hash of the ledger history\naccumulator at some version and other metadata is a binding commitment to\nthe ledger history up to this version. Validators sign the corresponding\n",Object(o.b)("em",{parentName:"p"},"LedgerInfo")," structure every time they agree on a set of transactions and their\nexecution outcome. For each ",Object(o.b)("em",{parentName:"p"},"LedgerInfo")," structure that is stored, a set of\nsignatures on this structure from validators are also stored, so\nclients can verify the structure if they have obtained the public key of each\nvalidator."),Object(o.b)("h2",{id:"implementation-details"},"Implementation Details"),Object(o.b)("p",null,"The storage module uses ",Object(o.b)("a",{parentName:"p",href:"https://rocksdb.org/"},"RocksDB")," as its physical storage\nengine. Since the storage module needs to store multiple types of data, and\nkey-value pairs in RocksDB are byte arrays, there is a wrapper on top of RocksDB\nto deal with the serialization of keys and values. This wrapper enforces that all data in and\nout of the DB is structured according to predefined schemas."),Object(o.b)("p",null,"The core module that implements the main functionalities is called ",Object(o.b)("em",{parentName:"p"},"DiemDB"),".\nWhile we use a single RocksDB instance to store the entire set of data, related\ndata are grouped into logical stores ","\u2014"," for example, ledger store, state store,\nand transaction store, etc."),Object(o.b)("p",null,"For the sparse Merkle tree that represents ledger state, we optimize the disk\nlayout by using branch nodes with 16 children that represents 4-level subtrees\nand extension nodes that represents a path without branches. However, we still\nsimulate a binary tree when computing the root hash and proofs. This modification\nresults in proofs that are shorter than the ones generated by Ethereum's Merkle\nPatricia tree."),Object(o.b)("h2",{id:"how-is-this-module-organized"},"How is this module organized?"),Object(o.b)("pre",null,Object(o.b)("code",{parentName:"pre"},"    storage\n          \u2514\u2500\u2500 accumulator      # Implementation of Merkle accumulator.\n          \u2514\u2500\u2500 diemdb          # Implementation of DiemDB.\n          \u2514\u2500\u2500 schemadb         # Schematized wrapper on top of RocksDB.\n          \u2514\u2500\u2500 scratchpad       # In-memory representation of Diem core data structures used by execution.\n          \u2514\u2500\u2500 jellyfish-merkle # Implementation of sparse Merkle tree.\n          \u2514\u2500\u2500 state_view       # An abstraction layer representing a snapshot of state where the Move VM reads data.\n          \u2514\u2500\u2500 storage_client   # A Rust wrapper on top of GRPC clients.\n          \u2514\u2500\u2500 storage_proto    # All interfaces provided by the storage module.\n          \u2514\u2500\u2500 storage_service  # Storage module as a GRPC service.\n")))}d.isMDXComponent=!0},185:function(e,t,r){"use strict";r.d(t,"a",(function(){return u})),r.d(t,"b",(function(){return m}));var n=r(0),a=r.n(n);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function s(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?s(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):s(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var l=a.a.createContext({}),d=function(e){var t=a.a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=d(e.components);return a.a.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.a.createElement(a.a.Fragment,{},t)}},h=a.a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,o=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),u=d(r),h=n,m=u["".concat(s,".").concat(h)]||u[h]||p[h]||o;return r?a.a.createElement(m,i(i({ref:t},l),{},{components:r})):a.a.createElement(m,i({ref:t},l))}));function m(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var o=r.length,s=new Array(o);s[0]=h;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:n,s[1]=i;for(var l=2;l<o;l++)s[l]=r[l];return a.a.createElement.apply(null,s)}return a.a.createElement.apply(null,r)}h.displayName="MDXCreateElement"},281:function(e,t,r){"use strict";r.r(t),t.default=r.p+"assets/images/data-3b242a41f113678a901311c6800daf30.png"}}]);